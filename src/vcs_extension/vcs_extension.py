##############################################################################
# COPYRIGHT Ericsson AB 2014
#
# The copyright to the computer program(s) herein is the property of
# Ericsson AB. The programs may be used and/or copied only with written
# permission from Ericsson AB. or in accordance with the terms and
# conditions stipulated in the agreement/contract under which the
# program(s) have been supplied.
##############################################################################

import binascii
import json
from platform import uname
from distutils.version import LooseVersion

from litp.core.model_type import (
   ItemType, Property, PropertyType, Collection, RefCollection, View)
from litp.core.extension import ModelExtension
from litp.core.validators import (
    ItemValidator, ValidationError, IntRangeValidator)
from litp.core.litp_logging import LitpLogger
from litp.core.exceptions import ViewError

NEO4J_ID = "sg_neo4j_clustered_service"
log = LitpLogger()


def property_updated(item, prop):
    """
    Compare the property with value in applied_properties. This function
    considers and empty string '' and None to be equivalent properties.
    """
    value = getattr(item, prop)
    app_prop_value = item.applied_properties.get(prop)
    value = None if value == '' else value
    app_prop_value = None if app_prop_value == '' else app_prop_value

    return value != app_prop_value


class VcsExtension(ModelExtension):
    """
    *Allows for the installation and  configuration of a SFHA, VCS software*
    *on the managed nodes*
    """

    def define_property_types(self):
        netname_re = r"[a-zA-Z][a-zA-Z0-9._-]*"
        csv_re = r"^(%s|(%s,)+%s)$" % (netname_re, netname_re, netname_re)

        property_types = list()
        property_types.append(PropertyType("cluster_type",
                                           regex=r"^(vcs|sfha)$"),)
        property_types.append(PropertyType("vcs_cluster_id", validators=[
            IntRangeValidator(min_value=1, max_value=65535)]))
        property_types.append(PropertyType("net_names", regex=csv_re))
        property_types.append(PropertyType("default_nic_mon_type",
                            regex=r"^(netstat|mii)$"))
        property_types.append(PropertyType("cs_initial_online_type",
                            regex=r"^(off|on)$"))
        property_types.append(PropertyType("app_agent_num_threads",
                                           validators=[IntRangeValidator(
                                                        min_value=1,
                                                        max_value=50)]))
        property_types.append(PropertyType("vcs_seed_threshold",
                            validators=[IntRangeValidator(min_value=1)]))

        return property_types

    def define_item_types(self):
        """
        Defining Item types for vc cluster ID and cluster UUID
        will be generated by the plugin and there is no need
        to provide this by user
        """
        item_types = list()
        item_types.append(
            ItemType(
                "vcs-cluster",
                extend_item='cluster',
                item_description="This item type represents a VCS cluster. "
                "A VCS cluster is a cluster of nodes with high availability, "
                "where high availability management is provided by Symantec "
                "Cluster Server.",
                validators=[VcsClusterValidator(),
                            VcsClusterHaManagerValidator()],
                low_prio_net=Property("basic_string",
                                      prop_description="Network name to "
                                      "use as the low priority LLT link.",
                                      required=True, updatable_rest=False),
                llt_nets=Property("net_names",
                                  prop_description="Comma separated list "
                                  "of network names to use as LLT links.",
                                  required=True, updatable_rest=False),
                default_nic_monitor=Property("default_nic_mon_type",
                            prop_description=("The tool used to monitor " +
                            "NICs if no VCS network hosts have been " +
                            "defined for the cluster. The property can " +
                            "be set to either 'netstat' or 'mii'."),
                            default="netstat"),
                fencing_disks=Collection("disk-base",
                                         require="nodes",
                                         min_count=0, max_count=3),
                cluster_type=Property("cluster_type",
                                      prop_description="Cluster type "
                                      "(vcs|sfha).",
                                      updatable_rest=False,
                                      required=True),
                cs_initial_online=Property(
                    "cs_initial_online_type",
                    prop_description="Whether a vcs-clustered-service is "
                    "brought online or offline in the cluster when it is "
                    "initially created.",
                    required=True,
                    configuration=False,
                    default='on'),
                cluster_id=Property(
                    "vcs_cluster_id",
                    required=True,
                    updatable_rest=False,
                    site_specific=True,
                    prop_description="Unique ID for the VCS cluster."),
                critical_service=Property(
                    "basic_string",
                    deprecated=True,
                    prop_description=(
                        "The item_id of the service that is to be considered "
                        "a critical service when determining the node upgrade "
                        "order. Only one 'vcs-clustered-service' can be "
                        "specified as a critical service in a 'vcs-cluster'."
                    )
                ),
                node_upgrade_ordering=View(
                   "basic_list",
                    VcsExtension.get_node_upgrade_ordering,
                    deprecated=True,
                    view_description="A comma separated list of the node IDs "
                                     "ordered for an upgrade. The ordering is "
                                     "determined from the critical "
                                     "'vcs-clustered-service', if one is "
                                     "specified. Otherwise the core sets the "
                                     "ordering."
                ),
                storage_profile=RefCollection("storage-profile"),
                network_hosts=Collection("vcs-network-host"),
                app_agent_num_threads=Property(
                    "app_agent_num_threads",
                    prop_description="The number of threads the VCS "
                                     "application agent uses to manage "
                                     "application resources."
                ),
                vcs_seed_threshold=Property(
                    "vcs_seed_threshold",
                    updatable_plugin=False,
                    updatable_rest=True,
                    required=False,
                    prop_description=(
                        "When a cluster is booting, this property determines "
                        "the minimum number of nodes that must be running to "
                        "allow VCS to form a cluster. That is, it defines "
                        "the threshold value to allow GAB to start seeding "
                        "automatically. If the property is not defined in "
                        "the model, the plugin will set the threshold value "
                        "using the formula n/2+1."
                    )
                ),
                grub_lv_enable=Property(
                    "basic_boolean",
                    prop_description=("When this property is set to 'true' "
                        "all logical volumes will be set in the boot commands "
                        "in the GRUB configuration. When this property is set "
                        "to 'false' only the root and swap logical volumes "
                        "will be set in the boot commands in the GRUB "
                        "configuration"
                    ),
                    default="false"
                )
            )
        )

        item_types.append(
            ItemType(
                "vcs-clustered-service",
                extend_item='clustered-service',
                filesystems=RefCollection("file-system"),
                item_description="This item type represents a VCS-specific "
                "shared clustered service which uses the VCS HA (Symantec "
                "high availability) manager that controls the cluster.",
                validators=[VcsCSDependencyListValidator(),
                            VcsCSInitialOnlineDependencyListValidator()],
                ipaddresses=Collection("vip"),
                online_timeout=Property(
                    "positive_integer",
                    prop_description=(
                        "Maximum time in seconds the plugin waits for the "
                        "status of the VCS Service Group to change to online. "
                        "This property is used in the calculation of the "
                        "timeout for the VCS unlock task. Unlock timeout is "
                        "calculated as online_timeout * (startup_retry_limit "
                        "+ 1) across vcs-clustered-services in a vcs-cluster. "
                        "This property is used in the calculation of the "
                        "timeout for the VCS lock task. That timeout is "
                        "calculated as maximum value of offline_timeout + "
                        "(online_timeout * (startup_retry_limit + 1)) across "
                        "vcs-clustered-services in a vcs-cluster."
                    ),
                    required=True,
                    default="300"),
                offline_timeout=Property(
                    "positive_integer",
                    prop_description=(
                        "Maximum time in seconds the plugin waits for the "
                        "status of the VCS Service Group to change to offline."
                        " This property is used in the calculation of the "
                        "timeout for the VCS lock task. That timeout is "
                        "calculated as maximum value of offline_timeout + "
                        "(online_timeout * (startup_retry_limit + 1)) across "
                        "vcs-clustered-services in a vcs-cluster."
                    ),
                    required=True,
                    default="300"),
                deactivates=Property(
                    "basic_string",
                    prop_description=("Item_id of already deployed "
                         "vcs-clustered-service that is to be deactivated "
                         "during the deployment of this vcs-clustered-service."
                    ),
                    updatable_plugin=False,
                    updatable_rest=True,
                    required=False,
                ),
                deactivated=Property(
                    "basic_boolean",
                    prop_description=("Whether a vcs-clustered-service is "
                                      "deactivated and removed when the next "
                                      "plan is run."
                    ),
                    updatable_plugin=True,
                    updatable_rest=False,
                    required=False,
                ),
                triggers=Collection("vcs-trigger"),
                initial_online_dependency_list=Property(
                    "basic_list",
                    prop_description="A comma separated list of the "
                                     "vcs-clustered-service item IDs that are "
                                     "brought online before the creation of "
                                     "this vcs-clustered-service."),
            )
        )

        item_types.append(
            ItemType(
                "vcs-network-host",
                item_description="This item type represents an IPv4 or IPv6 "
                "address used for populating the NetworkHosts parameter in "
                "the VCS NIC service group.",
                network_name=Property("basic_string", required=True,
                    prop_description=("Network associated with VCS NIC "
                    "service group"), updatable_rest=False),
                ip=Property("ipv4_or_ipv6_address",
                    required=True, prop_description=("IP address to be "
                    "included in the VCS NetworkHosts"), updatable_rest=False)
            ))

        item_types.append(
            ItemType("vcs-trigger",
                     item_description="This item type represents a VCS "
                                      "trigger. A trigger lets you invoke "
                                      "a user-defined script for a specified "
                                      "event in a cluster.",
                     trigger_type=Property("any_string",
                                   prop_description="The trigger type. "
                                        "Currently only the 'nofailover' "
                                        "and 'postonline' types are "
                                        "supported. The nofailover trigger "
                                        "is executed when the service group "
                                        "cannot failover. The postonline "
                                        "trigger is executed after the "
                                        "service comes online.",
                                   updatable_rest=False,
                                   required=True),
                    service_argument=Property("basic_string",
                                   prop_description="The command line argument"
                                        " triggered on the service. This"
                                        " property is not currently used"
                                        " in LITP.",
                                   updatable_rest=False),
                    service_id=Property("basic_string",
                                   prop_description="The service ID of the "
                                        "inherited service to which the "
                                        "trigger is applied. This property "
                                        "is not currently used in LITP.",
                                   updatable_rest=False),
                    validators=[VCSTriggerTypeValidator()],
            ),
        )
        return item_types

    @staticmethod
    def _get_critical_cs(cluster):
        """
        Return the critical service item unless the critical service is
        deactivating the previous critical service, in which case the applied
        properties critical service is returned.
        """
        vcs_clustered_services = cluster.query('vcs-clustered-service',
                                            item_id=cluster.critical_service)
        if vcs_clustered_services:
            critical_cs = vcs_clustered_services[0]

            if (cluster.is_updated() and
                    property_updated(cluster, 'critical_service') and
                    critical_cs.deactivates):
                vcs_clustered_services = cluster.query('vcs-clustered-service',
                    item_id=cluster.applied_properties.get('critical_service'))
                if vcs_clustered_services:
                    app_critical_cs = vcs_clustered_services[0]
                    if (critical_cs.deactivates == app_critical_cs.item_id and
                        app_critical_cs.applied_properties.get('deactivated')
                                                                    != 'true'):
                        return app_critical_cs
        return critical_cs

    @staticmethod
    def is_ffl_in_use(plugin_api_context, cluster):
        """
        Checks if the cluster is a Causal Cluster and if the node upgrade
        order is in the sequence FFL by:
            1. Neo4j SG exists
            2. Neo4j SG has a node list length of 3
            3. Neo4j SG is not frozen
        :param plugin_api_context: The whole plugin_api_context instance.
        :param cluster: A query item instance of the cluster.
        :return: Neo4j sg is a FFL causal cluster else []
        """
        NEO4J_GROUP = 'Grp_CS_{0}_{1}'.format(cluster.item_id, NEO4J_ID)

        neo4j_service_list = cluster.query('vcs-clustered-service',
                                item_id=NEO4J_ID)
        if neo4j_service_list:
            neo4j_service = neo4j_service_list[0]
            neo4j_node_list = neo4j_service.node_list.split(',')
            if len(neo4j_node_list) == 3:
                for node in cluster.nodes:
                    if node.item_id in neo4j_node_list:
                        hostname = node.hostname
                        log.trace.debug('Check if service group "{0}" is '
                                        'frozen on node "{1}"'.
                                        format(NEO4J_GROUP, hostname))
                        result = plugin_api_context.rpc_command(
                            [hostname],
                            'vcs_node_upgrade_ordering_api',
                            'hagrp_display_frozen',
                            {'group_name': NEO4J_GROUP})
                        try:
                            data = result[hostname]['data']
                            if data['out']:
                                log.trace.debug('The SG "{0}" is '
                                                'Frozen'.format(NEO4J_GROUP))
                            else:
                                log.trace.debug('The SG "{0}" is not '
                                                'Frozen'.format(NEO4J_GROUP))
                                return neo4j_node_list
                        except KeyError as e:
                            log.trace.error('Unable to check if service group '
                                            '"{0}" on node "{1}" is frozen: '
                                            ''.format(NEO4J_GROUP,
                                                      node.hostname, e))
            else:
                log.trace.debug('SG "{0}" node_list "{1}" does '
                                'not have a length of 3'.
                                format(neo4j_service.vpath,
                                    neo4j_service.node_list))
        else:
            log.trace.debug('SG "{0}" not found on cluster "{1}"'.
                            format(NEO4J_GROUP, cluster.item_id))
        return []

    @staticmethod
    def is_valid_node_upgrade_scenario(node, cluster):
        """
        Check whether the conditions have been met to allow an upgrade of FFL
        :param node: A query item instance of the node
        :param cluster: A query item instance of the cluster
        :return: boolen does node meet the criteria for upgrade.
        """
        return not node.is_for_removal() and not node.is_initial() \
               or node.is_initial() and \
               VcsExtension.is_os_reinstall_on_peer_nodes(cluster)

    @staticmethod
    def is_os_reinstall_on_peer_nodes(cluster):
        """
        Check whether the conditions have been met for OS Re-Install of cluster
        :param cluster: A query item instance of the cluster
        :return: boolen
        """
        return any([True for node in cluster.nodes
                    for upgrd_item in node.query('upgrade')
                    if hasattr(upgrd_item, 'os_reinstall')
                    and upgrd_item.os_reinstall == 'true'])

    @staticmethod
    def get_ffl_cluster_overview(plugin_api_context, cluster):
        """
        Get an overview of the FFL causal cluster setup
        :param plugin_api_context: The whole plugin_api_context instance.
        :param cluster: A query item instance of the cluster.
        :return: A list of neo4j dictionary's with the LEADER as the last item
        """
        ffl_overview = []
        neo4j_service = cluster.query('vcs-clustered-service',
                                      item_id=NEO4J_ID)

        if neo4j_service:
            hostname = [node.hostname for node in cluster.nodes
                        if VcsExtension.is_valid_node_upgrade_scenario(
                    node, cluster) and node.item_id in
                        neo4j_service[0].node_list.split(',')[0]]

            if hostname:
                results = plugin_api_context.rpc_command([hostname[0]],
                         'vcs_node_upgrade_ordering_api',
                         'causal_cluster_overview')
                data = results[hostname[0]]['data']
                out = data.get('out', '')

                if out is None:
                    log.trace.error('Unable to get FFL causal cluster '
                                        'overview')
                elif 'instances' in out:
                    ffl_overview = json.loads(results[hostname[0]]
                                            ['data']['out'])['instances']
        return ffl_overview

    @staticmethod
    def get_leader_node_from_cluster_model(cluster, hostname):
        """
        Find and return the nodes item id
        :param cluster: A query item instance of the cluster
        :param hostname: Hostname of the leader from the neo4j FFL overview
        :return: node item id
        """
        leader_node = cluster.query(
            'node', hostname=hostname)
        if leader_node:
            leader = leader_node[0].item_id
            return leader
        else:
            error_message = 'Node hostname "{0}" in FFL ' \
                            'overview not found in cluster ' \
                            '"{1}"'.format(hostname,
                                           cluster.vpath)
            log.trace.error(error_message)

    @staticmethod
    def get_leader_node_from_ffl_overview(cluster, ffl_overview, element):
        """
        Find and return either the DPS Leader or the System Leader from
        the neo4j FFL overview
        :param cluster: A query item instance of the cluster
        :param ffl_overview: A list of the neo4j dictionary
        :param element: 'dps' or 'system' indicating the leader to be returned
        :return: The DPS Leader or the System leader node item id
        """
        if element == 'dps' or element == 'system':
            try:
                for idx in range(len(ffl_overview)):
                    if ffl_overview[idx]['databases'][element] == "LEADER":
                        leader_hostname = ffl_overview[idx]['host']['hostname']
                        if leader_hostname:
                            leader_node = VcsExtension.\
                                get_leader_node_from_cluster_model(
                                    cluster, leader_hostname)
                            return leader_node

            except KeyError as e:
                log.trace.error('Unable to parse FFL overview as '
                                'key {0} not found'.format(e))

        else:
            error_message = ('Element passed is not correct. '
                             'It must be \'dps\' or \'system\' to '
                             'find the DPS or System Leaders.')
            log.trace.error(error_message)

    @staticmethod
    def get_causal_cluster_ffl_ordering(
            plugin_api_context, cluster, ffl_node_list):
        """
        If it's a Causal Cluster FFL in the 'vcs-cluster',
        then the returned list contains the node item_id values of all nodes
        in the cluster in the following order: non-ffl node, if any,
        the Follower node then the System Leader node and lastly the
        DPS Leader node.
        To avoid unnecessary leader re-elections, the System Leader is executed
        second to last with the DPS Leader executed last.
        Any nodes not part of the FFL are added to the start of the list
        :param plugin_api_context: The whole plugin_api_context instance
        :param cluster: A query item instance of the cluster
        :param ffl_node_list: Neo4j SG node list
        :return: A list of node item_id values
        """
        sorted_nodes = []

        ffl_overview = VcsExtension.get_ffl_cluster_overview(
            plugin_api_context, cluster)

        # Find SYSTEM LEADER in ffl_overview
        system_leader_node = \
            VcsExtension.get_leader_node_from_ffl_overview(
                cluster, ffl_overview, "system")

        if system_leader_node:
            ffl_node_list.append(system_leader_node)
            ffl_node_list.remove(system_leader_node)

            # Find DPS LEADER in ffl_overview
            dps_leader_node = VcsExtension.get_leader_node_from_ffl_overview(
                cluster, ffl_overview, "dps")

            if dps_leader_node:
                ffl_node_list.append(dps_leader_node)
                ffl_node_list.remove(dps_leader_node)

                sorted_nodes = ffl_node_list

        if sorted_nodes:
            # Lastly insert any non FFL nodes at the start
            # of the ordered list
            for node in cluster.nodes:
                if node.item_id not in sorted_nodes:
                    sorted_nodes.insert(0, node.item_id)

            log.trace.debug('FFL upgrade ordered list: {0}'.
                            format(sorted_nodes))
            return sorted_nodes

        else:
            log.trace.debug('Ordered node list could not be created using '
                            'FFL data')
            return []

    @staticmethod
    def get_critical_service_standby_node(plugin_api_context, cluster,
                                          critical_cs, group_name):
        """
        If 'critical_service' property is present on the 'vcs-cluster', the
        returned list contains the node item_id values of all nodes in the
        cluster. The node that contains the critical service and is in standby
        should be first in the list, followed by the critical service active
        node and then any other nodes in the cluster
        :param plugin_api_context: The whole plugin_api_context instance
        :param cluster: A query item instance of the cluster
        :param critical_cs: critical service item
        :param group_name: Critical service Group name
        :return: A list of node item_id values

        Raises:
            ViewError: A ValueError occurred when executing the rpc_command or
                the rpc_command is not successful. The critical_service can
                also be in either ONLINE or OFFLINE states on both nodes.
        """
        sorted_nodes = [node.item_id for node in critical_cs.nodes]
        # need to loop since sys argument is required for the
        # hagrp_state action
        online_count = 0
        offline_count = 0
        for node in critical_cs.nodes:
            results = plugin_api_context.rpc_command(
                [node.hostname],
                'vcs_node_upgrade_ordering_api',
                'hagrp_state', {'group_name': group_name,
                                'sys': node.hostname})
            data = results[node.hostname]['data']
            out = data.get('out', '')
            if out is None:
                error_message = ('The node_upgrade_ordering view on '
                                 'the cluster "{0}" cannot execute '
                                 'because the rpc command is '
                                 'failing.').format(cluster.item_id)
                log.trace.error(error_message)
                raise ViewError(error_message)
            # could be expanded on the following conditions:
            # FAULTED, PARTIAL, STARTING, STOPPING, MIGRATING
            if 'ONLINE' in out:
                active_node_id = cluster.query(
                    'node', hostname=node.hostname)[0].item_id
                sorted_nodes.remove(active_node_id)
                sorted_nodes.append(active_node_id)
                online_count += 1
            elif 'OFFLINE' in out:
                offline_count += 1
            else:
                # Error raised if status does not contain ONLINE or OFFLINE:
                error_message = ('The status of the critical '
                                 'service "{0}" on the node "{1}" '
                                 'cannot be determined.').format(
                    critical_cs.item_id, node.hostname)
                log.trace.error(error_message)
                log.trace.error("Output of group state: " + out)
                raise ViewError(error_message)

        if online_count == 2:
            error_message = ('The status of the critical '
                             'service "{0}" is online on both nodes '
                             'on the cluster "{1}".').format(
                critical_cs.item_id,
                cluster.item_id)
            log.trace.error(error_message)
            raise ViewError(error_message)
        if offline_count == 2:
            # TORF-179470 New plan should be created regardless of
            # critical_service being OFFLINE or OFFLINE|FAULTED
            error_message = ('The status of the critical '
                             'service "{0}" is offline on both nodes '
                             'on the cluster "{1}".').format(
                critical_cs.item_id,
                cluster.item_id)
            log.trace.error(error_message)

        # append cluster nodes not in critical service
        sorted_nodes.extend(node.item_id
                            for node in cluster.nodes
                            if node not in critical_cs.nodes)

        return sorted_nodes

    @staticmethod
    def get_critical_service_ordering(plugin_api_context, cluster):
        """
        If 'critical_service' property is present on the 'vcs-cluster', the
        returned list contains the node item_id values of all nodes in the
        cluster. The node that contains the critical service and is in standby
        should be first in the list, followed by the critical service active
        node and then any other nodes in the cluster
        :param plugin_api_context: The whole plugin_api_context instance
        :param cluster: A query item instance of the cluster
        :return: A list of node item_id values if the 'critical_service'
                property is defined on the 'vcs-cluster' item.
                Otherwise, the list is empty.
        """
        sorted_nodes = []

        critical_cs = VcsExtension._get_critical_cs(cluster)
        if not (critical_cs.is_initial() or critical_cs.is_for_removal()):
            group_name = condense_name("Grp_CS_{0}_{1}".format(
                cluster.item_id, critical_cs.item_id))
            sorted_nodes = VcsExtension.get_critical_service_standby_node(
                plugin_api_context, cluster, critical_cs, group_name)

        return sorted_nodes

    @staticmethod
    def get_node_upgrade_ordering(plugin_api_context, cluster):
        """
        If it's a Causal Cluster FFL that is being used in the 'vcs-cluster',
        then the returned list contains the node item_id values of all nodes
        in the cluster in the following order: non-ffl node, if any,
        the Follower node then the System Leader node and lastly the
        DPS Leader node.
        To avoid unnecessary leader re-elections, the System Leader is executed
        second to last with the DPS Leader executed last.
        Any nodes not part of the FFL are added to the start of the list.

        If 'critical_service' property is present on the 'vcs-cluster', the
        returned list contains the node item_id values of all nodes in the
        cluster. The node that contains the critical service and is in standby
        should be first in the list, followed by the critical service active
        node and then any other nodes in the cluster.
        Args:
            plugin_api_context: The whole plugin_api_context instance.
            cluster: A query item instance of the cluster.
        Returns:
            A list of node item_id values if order can be determined.
            Otherwise, the list is empty.
        """
        sorted_nodes = []

        # Check if a Causal Cluster FFL is being used in the 'vcs-cluster'
        ffl_node_list = VcsExtension.is_ffl_in_use(plugin_api_context,
                                                   cluster)
        if ffl_node_list:
            sorted_nodes = VcsExtension.get_causal_cluster_ffl_ordering(
                plugin_api_context, cluster, ffl_node_list)

        # Check if 'critical_service' property is present on the 'vcs-cluster'
        elif cluster.critical_service is not None:
            sorted_nodes = VcsExtension.get_critical_service_ordering(
                plugin_api_context, cluster)

        if sorted_nodes:
            log.trace.debug('node_upgrade_ordering: %s' % sorted_nodes)
        else:
            log.trace.debug('node_upgrade_ordering handled by core')
        return sorted_nodes

    @staticmethod
    def get_package_file_info(plugin_api_context, hostname, package,
                              greps=None):
        """
        List the files in a package and optionally filter them
        :param plugin_api_context: The whole plugin_api_context instance
        :param hostname: The node to run this action on
        :param package: The rpm package to check
        :param greps: List of strings to grep for
        :return: List of pattern matched files found in the package
        :rtype: str
        """
        if greps is None:
            greps = []

        log.trace.debug("On node {0} get information for package: "
                          "'{1}'.".format(hostname, package))
        action = "get_package_file_info"
        args = ["package={0}".format(package)]
        log.trace.debug("Execute MCO action '{0}' on node:{1} with args:{2} "
                        .format(action, hostname, args))

        results = plugin_api_context.rpc_command(
                            [hostname],
                            'vcs_engine_upgrade_api',
                            'get_package_file_info',
                            {'package': package})

        data = results[hostname]['data']
        pkg_info = data.get('out', '')
        pkg_info_list = pkg_info.splitlines()

        if greps:
            for grep in greps:
                rm_info = []
                for info in pkg_info_list:
                    if grep not in info:
                        rm_info.append(info)
                pkg_info_list = list(set(pkg_info_list) - set(rm_info))

        log.trace.debug("Node {0}: Selected the following debug files from "
                        "package {1}. '{2}'".format(hostname, package,
                                                    pkg_info_list))
        return pkg_info_list

    @staticmethod
    def get_current_kernel_version():
        """
        Return the current version of the RHEL kernel
        """
        return '.'.join(uname()[2].split(".")[0:3])

    @staticmethod
    def get_latest_debug_file(hostname, debug_files):
        """
        Get the current deployment Linux version
        """
        current_kernel_release = VcsExtension.get_current_kernel_version()
        log.trace.debug('Current kernel release is : {0}'.format(
            current_kernel_release))

        # Get the latest available VRTS debug file which is compatible
        # with the deployment Linux version.
        latest_debug_file_ver = "0"
        for db_file in debug_files:
            df_ver = '.'.join((db_file.split('/')[5]).split(".")[2:5])
            log.trace.debug("Check version of file: {0}".format(df_ver))
            if LooseVersion(latest_debug_file_ver) < \
                    LooseVersion(df_ver) <= \
                    LooseVersion(current_kernel_release):
                latest_debug_file_ver = df_ver
                log.trace.debug("Node {0}: Updated latest debug file version "
                                "to: {1}".format(hostname,
                                                 latest_debug_file_ver))
            log.trace.debug("Node {0}: Current debug file version is: {1}"
                            .format(hostname, latest_debug_file_ver))

        log.trace.debug("Node {0}: Chosen latest debug file verion = {1}"
                        .format(hostname, latest_debug_file_ver))

        return latest_debug_file_ver

    @staticmethod
    def remove_unused_vrts_debug_files(plugin_api_context, hostname,
                                       debug_files):
        """
        Remove unneeded VRTS debug files after the Upgrade procedure.
        :return: None
        """
        latest_debug_file_ver = VcsExtension.get_latest_debug_file(
                                                 hostname, debug_files)
        log.trace.info("Node {0}: Remove all debuginfo files except for "
                       "version '{1}'".format(hostname, latest_debug_file_ver))

        for debfile in debug_files:
            log.trace.debug("Node {0}: Check file for deletion: {1}"
                            .format(hostname, debfile))
            results = plugin_api_context.rpc_command(
                [hostname],
                'vcs_engine_upgrade_api',
                'file_exists',
                {'file': debfile})
            data = results[hostname]['data']
            file_exists = data.get('out', '')

            if latest_debug_file_ver not in debfile and file_exists:
                log.trace.info("Node {0}: Delete File '{1}'"
                               .format(hostname, debfile))
                plugin_api_context.rpc_command(
                    [hostname],
                    'vcs_engine_upgrade_api',
                    'delete_file',
                    {'file': debfile})


class VcsClusterHaManagerValidator(ItemValidator):
    """
    Validate the `ha_manager` property of `vcs-cluster`.

    The sole concern of the `ha_manager` property is to indicate
    if a node lock operation will be triggered on updates on a
    cluster.

    A value of `vcs` indicates that a node lock will
    be triggered. To disable node locking an empty string value:
    "" should be set as the value for this property.
    """
    VALID_HA_MANAGERS = ('vcs', '')

    def validate(self, properties):
        if not self.valid_ha_manager(properties.get('ha_manager', 'vcs')):
            error_message = "Invalid value '%s'." % properties.get(
                'ha_manager')
            return ValidationError(
                property_name="ha_manager",
                error_message=error_message)

    def valid_ha_manager(self, ha_manager):
        return ha_manager in self.VALID_HA_MANAGERS


class VcsClusterValidator(ItemValidator):
    """
    Custom ItemValidator for vcs-cluster item type.

    Validates following constraints:
    - Maximum 7 llt links
    - Maximum 1 llt low priority link

    .. note:
        The recommended value for llt links is 2
    """

    def validate(self, properties):
        # This is probably a candidate for extrace method, validation.
        low_prio_net_val = properties.get("low_prio_net")
        llt_nets_val = properties.get("llt_nets")
        failed_property = None
        if not llt_nets_val:
            failed_property = "llt_nets"
        elif not low_prio_net_val:
            failed_property = "low_prio_net"
        if failed_property:
            return ValidationError(property_name=failed_property,
                                   error_message="Property should not be "
                                   "empty")
        llt_nets = llt_nets_val.split(",")

        llt_nets_all = llt_nets + [low_prio_net_val]

        if len(low_prio_net_val.split(",")) > 1:
            return ValidationError(
                property_name="low_prio_net",
                error_message="Low priority link for LLT should not be a list")

        dups = set([x for x in llt_nets_all if llt_nets_all.count(x) > 1])
        if dups:
            return ValidationError(
                property_name="llt_nets",
                error_message=(
                    "Cannot create more than one link for each network"))

        if len(llt_nets) > 7:
            return ValidationError(
                property_name="llt_nets",
                error_message="Cannot set more than 7 links for LLT")


class VcsCSDependencyListValidator(ItemValidator):
    """
    Custom Validator for vcs-clustered-service item type.

    Validates that there are no more than 64 items in the dependency list.
    Validates for multiple usages in the dependency_list.
    """
    MAXIMUM_NUMBER_DEPENDENCIES = 64

    def validate(self, properties):
        dependencies_list_str = properties.get("dependency_list")
        if not dependencies_list_str:
            return

        dependencies_list = dependencies_list_str.split(",")

        if len(dependencies_list) > self.MAXIMUM_NUMBER_DEPENDENCIES:
            return ValidationError(
                property_name="dependency_list",
                error_message=(
                    'There are "{0}" dependencies specified. The maximum'
                    ' number of dependencies supported is "{1}".'.format(
                    len(dependencies_list), self.MAXIMUM_NUMBER_DEPENDENCIES)
                    ))

        multiple_usages = set(dep for dep in dependencies_list if
            dependencies_list.count(dep) > 1)
        if multiple_usages:
            return ValidationError(
                property_name="dependency_list",
                error_message=(
                    "The following vcs-clustered-services have been specified"
                    " more than once: {0}.".format(', '.join(multiple_usages))
                    ))


class VcsCSInitialOnlineDependencyListValidator(ItemValidator):
    """
    Custom Validator for vcs-clustered-service item type.

    Validates that there are no more than 64 items in the
        initial_online_dependency_list.
    Validates for multiple usages in the initial_online_dependency_list.
    Validates that the same dependency is not in both dependency_list and
        initial_online_dependency_list
    """
    MAXIMUM_NUMBER_DEPENDENCIES = 64

    def validate(self, properties):
        init_online_dep_list_str = properties.get(
            "initial_online_dependency_list")
        if not init_online_dep_list_str:
            return

        init_online_dep_list = init_online_dep_list_str.split(",")

        if len(init_online_dep_list) > self.MAXIMUM_NUMBER_DEPENDENCIES:
            return ValidationError(
                property_name="initial_online_dependency_list",
                error_message=(
                    'There are "{0}" dependencies specified. The maximum'
                    ' number of dependencies supported is "{1}".'.format(
                        len(init_online_dep_list),
                        self.MAXIMUM_NUMBER_DEPENDENCIES)
                    ))

        multiple_usages = set(dep for dep in init_online_dep_list if
                              init_online_dep_list.count(dep) > 1)
        if multiple_usages:
            return ValidationError(
                property_name="initial_online_dependency_list",
                error_message=(
                    "The following vcs-clustered-services have been specified"
                    " more than once: {0}.".format(', '.join(multiple_usages))
                    ))


class VCSTriggerTypeValidator(ItemValidator):
    """
    Validates trigger_type property
    """

    def validate(self, properties):
        trigger_type = properties.get('trigger_type')

        if trigger_type is not None and trigger_type not in ['nofailover',
                                                             'postonline']:
            return ValidationError(
                property_name="trigger_type",
                error_message="Only \"nofailover\" and \"postonline\" "
                            "trigger types currently supported.")


def condense_name(name, size=60):
    '''
    A method to condense a string, but still keep the uniqueness of the string
    The method removes the last 10 characters of the string, and replaces it
    with the crc32 hex representation of the entire string.
    It is called to ensure all VCS group and resource names are 60 characters
    or less, to improve readability for the user.
    Note: This same method must go into vcs and vol manager plugins!
    '''
    if len(name) > size - 1:
        name = name[:size - 10] + '_' + \
            hex(binascii.crc32(name) & 0xffffffff).lstrip('0x').rstrip('L')
        # . and - are unsupported characters in VCS naming
    return name.replace(".", "_").replace("-", "_")
